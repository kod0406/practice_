/**
 * ÎèÖÎ¶ΩÏ†ÅÏù∏ Ï±óÎ¥á Î™®Îìà v2.0
 * Ïñ¥Îñ§ HTML ÌéòÏù¥ÏßÄÏóêÏÑúÎèÑ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î≤îÏö© Ï±óÎ¥á
 *
 * ÏÇ¨Ïö©Î≤ï:
 * const chatbot = new ChatbotModule({
 *     apiKey: 'your-api-key',
 *     position: 'bottom-right'
 * });
 */

class ChatbotModule {
    constructor(options = {}) {
        this.options = {
            apiKey: options.apiKey || null,
            container: options.container || 'chatbot-container',
            layoutPath: options.layoutPath || './chatbot_layout.html',
            cssPath: options.cssPath || './chatbot.css',
            autoInit: options.autoInit !== false,
            position: options.position || 'bottom-right',
            theme: options.theme || 'light', // light, dark
            enableFileUpload: options.enableFileUpload !== false,
            enableEmoji: options.enableEmoji !== false,
            maxFileSize: options.maxFileSize || 5 * 1024 * 1024, // 5MB
            ...options
        };

        this.isInitialized = false;
        this.chatHistory = [];
        this.userData = {
            message: null,
            file: { data: null, mimeType: null }
        };

        // Í≥†Ïú† Ïù∏Ïä§ÌÑ¥Ïä§ ID ÏÉùÏÑ±
        this.instanceId = 'chatbot-' + Math.random().toString(36).substr(2, 9);
        this.elements = {};

        if (this.options.autoInit) {
            this.init();
        }
    }

    async init() {
        if (this.isInitialized) return;

        try {
            await this.loadCSS();
            await this.loadLayout();
            this.initializeEventListeners();
            this.applyTheme();
            this.isInitialized = true;
            console.log('Chatbot Module initialized successfully');
            this.emit('initialized');
        } catch (error) {
            console.error('Failed to initialize chatbot:', error);
            this.emit('error', error);
        }
    }

    async loadCSS() {
        // Ï§ëÎ≥µ Î°úÎìú Î∞©ÏßÄ
        if (document.querySelector(`link[href*="chatbot.css"]`)) return;

        try {
            const isExtension = typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.getURL;
            const url = isExtension
                ? chrome.runtime.getURL(this.options.cssPath)
                : this.options.cssPath;

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            document.head.appendChild(link);

            return new Promise((resolve, reject) => {
                link.onload = resolve;
                link.onerror = () => {
                    console.warn('Failed to load CSS, using inline styles');
                    this.injectFallbackCSS();
                    resolve();
                };
            });
        } catch (error) {
            console.warn('Failed to load CSS:', error);
            this.injectFallbackCSS();
        }
    }

    injectFallbackCSS() {
        const style = document.createElement('style');
        style.textContent = `
            .chatbot-popup {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                position: fixed;
                width: 420px;
                max-width: 90vw;
                background: white;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                z-index: 9998;
                display: none;
            }
            #chatbot-toggle {
                position: fixed;
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: #5350C4;
                border: none;
                color: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                z-index: 9999;
                transition: all 0.3s ease;
            }
            #chatbot-toggle:hover { background: #3d39ac; }
            .chat-header { background: #5350C4; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
            .chat-body { height: 300px; padding: 20px; overflow-y: auto; }
            .chat-footer { padding: 15px; border-top: 1px solid #eee; }
            .chat-form { display: flex; gap: 10px; align-items: center; border: 1px solid #ddd; border-radius: 25px; padding: 8px 12px; }
            .message-input { flex: 1; border: none; outline: none; resize: none; min-height: 20px; font-family: inherit; }
            .message { margin-bottom: 10px; }
            .user-message .message-text { background: #5350C4; color: white; padding: 12px; border-radius: 12px; margin-left: auto; max-width: 80%; }
            .bot-message .message-text { background: #f2f2ff; padding: 12px; border-radius: 12px; max-width: 80%; }
            #send-message { background: #5350C4; color: white; border: none; border-radius: 50%; width: 35px; height: 35px; cursor: pointer; }
        `;
        document.head.appendChild(style);
    }

    async loadLayout() {
        const container = document.getElementById(this.options.container) || document.body;

        try {
            const isExtension = typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.getURL;
            const url = isExtension
                ? chrome.runtime.getURL(this.options.layoutPath)
                : this.options.layoutPath;

            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to load chatbot layout');

            const html = await response.text();
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;

            // Í≥†Ïú† ID Ï†ÅÏö©
            this.updateElementIds(wrapper);
            this.setPosition(wrapper, this.options.position);

            container.appendChild(wrapper);
            this.cacheElements();
            return true;
        } catch (error) {
            console.warn('Failed to load chatbot layout:', error);
            this.createFallbackLayout(container);
            return false;
        }
    }

    updateElementIds(wrapper) {
        // Í≥†Ïú†Ìïú IDÎ°ú Î≥ÄÍ≤ΩÌïòÏó¨ Îã§Ï§ë Ïù∏Ïä§ÌÑ¥Ïä§ ÏßÄÏõê
        const elements = wrapper.querySelectorAll('[id]');
        elements.forEach(el => {
            const oldId = el.id;
            const newId = `${oldId}-${this.instanceId}`;
            el.id = newId;

            // labelÏùò for ÏÜçÏÑ±ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            const labels = wrapper.querySelectorAll(`[for="${oldId}"]`);
            labels.forEach(label => label.setAttribute('for', newId));
        });
    }

    cacheElements() {
        this.elements = {
            toggle: document.querySelector(`#chatbot-toggle-${this.instanceId}`),
            popup: document.querySelector('.chatbot-popup'),
            closeBtn: document.querySelector(`#close-chatbot-${this.instanceId}`),
            chatBody: document.querySelector('.chat-body'),
            messageInput: document.querySelector('.message-input'),
            sendBtn: document.querySelector(`#send-message-${this.instanceId}`),
            fileInput: document.querySelector(`#file-input-${this.instanceId}`),
            fileUpload: document.querySelector(`#file-upload-${this.instanceId}`),
            fileCancel: document.querySelector(`#file-cancel-${this.instanceId}`),
            emojiBtn: document.querySelector(`#emoji-picker-${this.instanceId}`)
        };
    }

    setPosition(element, position) {
        const toggle = element.querySelector('[id*="chatbot-toggle"]');
        const popup = element.querySelector('.chatbot-popup');

        if (!toggle || !popup) return;

        const positions = {
            'bottom-left': { bottom: '30px', left: '35px' },
            'bottom-right': { bottom: '30px', right: '35px' },
            'top-left': { top: '30px', left: '35px' },
            'top-right': { top: '30px', right: '35px' }
        };

        const pos = positions[position] || positions['bottom-right'];
        Object.assign(toggle.style, pos);

        const popupPos = { ...pos };
        if (position.includes('bottom')) {
            popupPos.bottom = '90px';
            delete popupPos.top;
        } else {
            popupPos.top = '90px';
            delete popupPos.bottom;
        }
        Object.assign(popup.style, popupPos);
    }

    createFallbackLayout(container) {
        const fallbackHtml = `
            <button id="chatbot-toggle-${this.instanceId}" style="position: fixed; bottom: 30px; right: 35px; z-index: 9999; width: 50px; height: 50px; border-radius: 50%; background: #5350C4; border: none; color: white; cursor: pointer;">
                üí¨
            </button>
            <div class="chatbot-popup" style="position: fixed; right: 35px; bottom: 90px; width: 420px; max-width: 90vw; background: white; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); display: none; z-index: 9998;">
                <div class="chat-header" style="background: #5350C4; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; border-radius: 15px 15px 0 0;">
                    <h3 style="margin: 0; font-size: 1.2rem;">Chatbot</h3>
                    <button id="close-chatbot-${this.instanceId}" style="background: none; border: none; color: white; cursor: pointer; font-size: 24px;">&times;</button>
                </div>
                <div class="chat-body" style="height: 300px; padding: 20px; overflow-y: auto; background: #fafafa;">
                    <div class="message bot-message">
                        <div class="message-text" style="background: #f2f2ff; padding: 12px; border-radius: 12px; margin-bottom: 10px; max-width: 80%;">
                            ÏïàÎÖïÌïòÏÑ∏Ïöî! Ï±óÎ¥áÏûÖÎãàÎã§. ${this.options.apiKey ? 'Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?' : 'API ÌÇ§Î•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.'}
                        </div>
                    </div>
                </div>
                <div class="chat-footer" style="padding: 15px; border-top: 1px solid #eee; background: white; border-radius: 0 0 15px 15px;">
                    <div class="chat-form" style="display: flex; gap: 10px; align-items: center; border: 1px solid #ddd; border-radius: 25px; padding: 8px 12px;">
                        <textarea class="message-input" placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." style="flex: 1; border: none; outline: none; resize: none; min-height: 20px; font-family: inherit; background: transparent;"></textarea>
                        <button id="send-message-${this.instanceId}" style="background: #5350C4; color: white; border: none; border-radius: 50%; width: 35px; height: 35px; cursor: pointer; display: flex; align-items: center; justify-content: center;">‚û§</button>
                    </div>
                </div>
            </div>
        `;

        const wrapper = document.createElement('div');
        wrapper.innerHTML = fallbackHtml;
        container.appendChild(wrapper);
        this.cacheElements();
    }

    initializeEventListeners() {
        const { toggle, popup, closeBtn, sendBtn, messageInput, fileInput, fileUpload, fileCancel, emojiBtn } = this.elements;

        // ÌÜ†Í∏Ä Î≤ÑÌäº
        if (toggle) {
            toggle.addEventListener('click', () => this.toggleChat());
        }

        // Îã´Í∏∞ Î≤ÑÌäº
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.hide());
        }

        // Î©îÏãúÏßÄ Ï†ÑÏÜ°
        if (sendBtn && messageInput) {
            const handleSend = () => this.sendMessage();

            sendBtn.addEventListener('click', handleSend);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSend();
                }
            });

            // ÏûÖÎ†• Ïãú ÏûêÎèô ÌÅ¨Í∏∞ Ï°∞Ï†ï
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
            });
        }

        // ÌååÏùº ÏóÖÎ°úÎìú (ÏòµÏÖòÏù¥ ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞)
        if (this.options.enableFileUpload && fileInput && fileUpload) {
            fileUpload.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
            if (fileCancel) {
                fileCancel.addEventListener('click', () => this.cancelFileUpload());
            }
        }

        // Ïù¥Î™®ÏßÄ Î≤ÑÌäº (ÏòµÏÖòÏù¥ ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞)
        if (this.options.enableEmoji && emojiBtn) {
            emojiBtn.addEventListener('click', () => this.toggleEmojiPicker());
        }

        // API ÌÇ§ ÌÜ†Í∏Ä Í∏∞Îä• Ï¥àÍ∏∞Ìôî
        this.initializeApiKeyToggle();

        // Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
        document.addEventListener('click', (e) => {
            if (popup && !popup.contains(e.target) && !toggle.contains(e.target)) {
                // Ïû†Íπê ÎîúÎ†àÏù¥Î•º Ï£ºÏñ¥ Î≤ÑÌäº ÌÅ¥Î¶≠ ÏôÑÎ£å ÌõÑ Ïã§Ìñâ
                setTimeout(() => {
                    if (popup.style.display === 'block') {
                        this.hide();
                    }
                }, 100);
            }
        });
    }

    // API ÌÇ§ ÌÜ†Í∏Ä Í∏∞Îä• Ï¥àÍ∏∞Ìôî
    initializeApiKeyToggle() {
        const apiKeyHeader = document.querySelector(`#api-key-header-${this.instanceId}`) || document.querySelector('#api-key-header');
        const apiKeyContent = document.querySelector(`#api-key-content-${this.instanceId}`) || document.querySelector('#api-key-content');
        const apiToggleBtn = document.querySelector(`#api-toggle-btn-${this.instanceId}`) || document.querySelector('#api-toggle-btn');
        const apiKeyInput = document.querySelector(`#api-key-input-${this.instanceId}`) || document.querySelector('#api-key-input');
        const saveApiKeyBtn = document.querySelector(`#save-api-key-${this.instanceId}`) || document.querySelector('#save-api-key');
        const apiStatus = document.querySelector(`#api-status-${this.instanceId}`) || document.querySelector('#api-status');

        if (!apiKeyHeader || !apiKeyContent || !apiToggleBtn) return;

        // Ï¥àÍ∏∞ ÏÉÅÌÉúÏóêÏÑú API ÌÇ§ ÏÉÅÌÉú ÌôïÏù∏
        this.checkApiKeyStatus();

        // Ìó§Îçî ÌÅ¥Î¶≠ÏúºÎ°ú ÌÜ†Í∏Ä
        apiKeyHeader.addEventListener('click', (e) => {
            // ÎßÅÌÅ¨ÎÇò Î≤ÑÌäº ÌÅ¥Î¶≠ÏùÄ ÌÜ†Í∏ÄÌïòÏßÄ ÏïäÏùå
            if (e.target.tagName === 'A' || e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
            this.toggleApiSection();
        });

        // API ÌÇ§ Ï†ÄÏû• Î≤ÑÌäº
        if (saveApiKeyBtn && apiKeyInput) {
            saveApiKeyBtn.addEventListener('click', () => {
                const apiKey = apiKeyInput.value.trim();
                if (!apiKey) {
                    alert('API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }

                try {
                    this.setApiKey(apiKey);
                    apiStatus.textContent = '‚úÖ ÏÑ§Ï†ïÎê®';
                    apiStatus.className = 'api-status connected';
                    apiKeyInput.value = '';
                    
                    // ÌÜ†Í∏Ä ÏÑπÏÖò Îã´Í∏∞
                    this.toggleApiSection(false);
                    
                    alert('API ÌÇ§Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.');
                    
                    // Ïõ∞Ïª¥ Î©îÏãúÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
                    this.updateWelcomeMessage();
                } catch (error) {
                    console.error('API ÌÇ§ Ï†ÄÏû• Ïã§Ìå®:', error);
                    alert('API ÌÇ§ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
            });

            // Enter ÌÇ§Î°úÎèÑ Ï†ÄÏû• Í∞ÄÎä•
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveApiKeyBtn.click();
                }
            });
        }
    }

    toggleApiSection(force = null) {
        const apiKeyContent = document.querySelector(`#api-key-content-${this.instanceId}`) || document.querySelector('#api-key-content');
        const apiToggleBtn = document.querySelector(`#api-toggle-btn-${this.instanceId}`) || document.querySelector('#api-toggle-btn');
        
        if (!apiKeyContent || !apiToggleBtn) return;

        const isHidden = apiKeyContent.style.display === 'none';
        const shouldShow = force !== null ? force : isHidden;

        if (shouldShow) {
            apiKeyContent.style.display = 'block';
            apiToggleBtn.classList.add('expanded');
        } else {
            apiKeyContent.style.display = 'none';
            apiToggleBtn.classList.remove('expanded');
        }
    }

    checkApiKeyStatus() {
        const apiStatus = document.querySelector(`#api-status-${this.instanceId}`) || document.querySelector('#api-status');
        if (!apiStatus) return;

        if (this.options.apiKey) {
            apiStatus.textContent = '‚úÖ ÏÑ§Ï†ïÎê®';
            apiStatus.className = 'api-status connected';
        } else {
            apiStatus.textContent = '‚ùå ÎØ∏ÏÑ§Ï†ï';
            apiStatus.className = 'api-status';
        }
    }

    updateWelcomeMessage() {
        const { chatBody } = this.elements;
        if (!chatBody) return;

        const existingWelcome = chatBody.querySelector('.bot-message .message-text');
        if (existingWelcome) {
            existingWelcome.textContent = this.options.apiKey 
                ? 'ÏïàÎÖïÌïòÏÑ∏ÏöîüòÄ Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?' 
                : 'ÏïàÎÖïÌïòÏÑ∏ÏöîüòÄ API ÌÇ§Î•º ÏÑ§Ï†ïÌïòÎ©¥ ÎåÄÌôîÎ•º ÏãúÏûëÌï† Ïàò ÏûàÏñ¥Ïöî!';
        }
    }

    async sendMessage() {
        const { messageInput, chatBody } = this.elements;

        if (!messageInput || !chatBody) return;

        const message = messageInput.value.trim();
        if (!message && !this.userData.file?.data) return;

        // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
        this.addMessage(message, 'user');
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Î¥á ÏùëÎãµ Ï≤òÎ¶¨
        const thinkingMessage = this.addMessage('ÏÉùÍ∞ÅÏ§ë...', 'bot', true);

        try {
            const response = await this.callAPI(message);
            this.updateMessage(thinkingMessage, response);
            this.emit('message-sent', { message, response });
        } catch (error) {
            this.updateMessage(thinkingMessage, 'Ï£ÑÏÜ°Ìï©ÎãàÎã§. Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
            this.emit('error', error);
        }

        // ÌååÏùº Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        this.userData.file = { data: null, mimeType: null };
    }

    addMessage(content, type, isThinking = false) {
        const { chatBody } = this.elements;
        if (!chatBody) return null;

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}-message`;

        const messageText = document.createElement('div');
        messageText.className = 'message-text';

        const baseStyle = 'padding: 12px; border-radius: 12px; margin-bottom: 10px; word-wrap: break-word; line-height: 1.4;';
        messageText.style.cssText = type === 'user'
            ? baseStyle + 'background: #5350C4; color: white; margin-left: auto; max-width: 80%; text-align: left;'
            : baseStyle + 'background: #f2f2ff; max-width: 80%; color: #333;';

        messageText.textContent = content;
        if (isThinking) {
            messageText.classList.add('thinking');
            messageText.style.fontStyle = 'italic';
            messageText.style.opacity = '0.7';
        }

        messageDiv.appendChild(messageText);
        chatBody.appendChild(messageDiv);
        chatBody.scrollTop = chatBody.scrollHeight;

        return messageText;
    }

    updateMessage(messageElement, content) {
        if (messageElement) {
            messageElement.textContent = content;
            messageElement.classList.remove('thinking');
            messageElement.style.fontStyle = 'normal';
            messageElement.style.opacity = '1';
        }
    }

    async callAPI(message) {
        if (!this.options.apiKey) {
            return 'API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. setApiKey() Î©îÏÑúÎìúÎ•º ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò ÏÉùÏÑ± Ïãú apiKey ÏòµÏÖòÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.';
        }

        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.options.apiKey}`;

        // ÌååÏùºÏù¥ ÏûàÎäî Í≤ΩÏö∞ Ìè¨Ìï®
        const parts = [{ text: message }];
        if (this.userData.file?.data) {
            parts.push({ inline_data: this.userData.file });
        }

        this.chatHistory.push({
            role: 'user',
            parts: parts
        });

        const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: this.chatHistory,
                generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 1000
                }
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`API Ìò∏Ï∂ú Ïã§Ìå® (${response.status}): ${errorData.error?.message || response.statusText}`);
        }

        const data = await response.json();
        const botResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || 'ÏùëÎãµÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.';

        this.chatHistory.push({
            role: 'model',
            parts: [{ text: botResponse }]
        });

        return botResponse;
    }

    handleFileUpload(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        // ÌååÏùº ÌÅ¨Í∏∞ Ï≤¥ÌÅ¨
        if (file.size > this.options.maxFileSize) {
            alert(`ÌååÏùº ÌÅ¨Í∏∞Îäî ${this.options.maxFileSize / 1024 / 1024}MBÎ•º Ï¥àÍ≥ºÌï† Ïàò ÏóÜÏäµÎãàÎã§.`);
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const base64String = e.target.result.split(',')[1];
            this.userData.file = {
                data: base64String,
                mimeType: file.type,
                name: file.name
            };

            this.addMessage(`üìé ÌååÏùº Ï≤®Î∂ÄÎê®: ${file.name}`, 'user');
            event.target.value = ''; // ÌååÏùº ÏûÖÎ†• Ï¥àÍ∏∞Ìôî
        };

        reader.readAsDataURL(file);
    }

    cancelFileUpload() {
        this.userData.file = { data: null, mimeType: null };
        // UIÏóêÏÑú ÌååÏùº ÌëúÏãú Ï†úÍ±∞ Î°úÏßÅ Ï∂îÍ∞Ä Í∞ÄÎä•
    }

    toggleEmojiPicker() {
        // Ïù¥Î™®ÏßÄ ÌîΩÏª§ ÌÜ†Í∏Ä Î°úÏßÅ (Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨ ÌïÑÏöî)
        console.log('Emoji picker toggle - implement with external library');
    }

    // Í≥µÍ∞ú Î©îÏÑúÎìúÎì§
    toggleChat() {
        const { popup } = this.elements;
        if (!popup) return;

        const isVisible = popup.style.display === 'block';
        if (isVisible) {
            this.hide();
        } else {
            this.show();
        }
    }

    show() {
        const { popup } = this.elements;
        if (popup) {
            popup.style.display = 'block';
            this.emit('shown');
        }
    }

    hide() {
        const { popup } = this.elements;
        if (popup) {
            popup.style.display = 'none';
            this.emit('hidden');
        }
    }

    setApiKey(apiKey) {
        this.options.apiKey = apiKey;
        this.emit('api-key-set', apiKey);
    }

    setTheme(theme) {
        this.options.theme = theme;
        this.applyTheme();
    }

    applyTheme() {
        const { popup } = this.elements;
        if (!popup) return;

        if (this.options.theme === 'dark') {
            popup.classList.add('dark-theme');
        } else {
            popup.classList.remove('dark-theme');
        }
    }

    clearHistory() {
        this.chatHistory = [];
        const { chatBody } = this.elements;
        if (chatBody) {
            chatBody.innerHTML = `
                <div class="message bot-message">
                    <div class="message-text" style="background: #f2f2ff; padding: 12px; border-radius: 12px; margin-bottom: 10px; max-width: 80%;">
                        ÎåÄÌôî ÎÇ¥Ïó≠Ïù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§. ÏÉàÎ°úÏö¥ ÎåÄÌôîÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî!
                    </div>
                </div>
            `;
        }
        this.emit('history-cleared');
    }

    destroy() {
        const container = document.getElementById(this.options.container);
        if (container) {
            container.innerHTML = '';
        }
        this.isInitialized = false;
        this.emit('destroyed');
    }

    // Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú
    emit(eventName, data = null) {
        const event = new CustomEvent(`chatbot-${eventName}`, {
            detail: { instance: this, data }
        });
        document.dispatchEvent(event);
    }

    on(eventName, callback) {
        document.addEventListener(`chatbot-${eventName}`, (e) => {
            if (e.detail.instance === this) {
                callback(e.detail.data);
            }
        });
    }

    // Ï†ïÏ†Å Î©îÏÑúÎìú
    static createMultiple(configs) {
        return configs.map(config => new ChatbotModule(config));
    }

    static getVersion() {
        return '2.0.0';
    }
}

// Ï†ÑÏó≠ÏúºÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÍ≤å ÎßåÎì§Í∏∞
if (typeof window !== 'undefined') {
    window.ChatbotModule = ChatbotModule;
}

// Node.js ÌôòÍ≤Ω ÏßÄÏõê
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ChatbotModule;
}

// ÏûêÎèô Ï¥àÍ∏∞Ìôî (ÏòµÏÖò)
document.addEventListener('DOMContentLoaded', () => {
    // data-chatbot ÏÜçÏÑ±ÏùÑ Í∞ÄÏßÑ ÏöîÏÜåÍ∞Ä ÏûàÏúºÎ©¥ ÏûêÎèô Ï¥àÍ∏∞Ìôî
    const autoInitElements = document.querySelectorAll('[data-chatbot]');
    autoInitElements.forEach(element => {
        const options = {
            container: element.id || undefined
        };

        // data ÏÜçÏÑ±Îì§ÏùÑ ÏòµÏÖòÏúºÎ°ú Î≥ÄÌôò
        Object.keys(element.dataset).forEach(key => {
            if (key.startsWith('chatbot')) {
                const optionKey = key.replace('chatbot', '').toLowerCase();
                let value = element.dataset[key];

                // boolean Í∞í Ï≤òÎ¶¨
                if (value === 'true') value = true;
                if (value === 'false') value = false;

                options[optionKey] = value;
            }
        });

        new ChatbotModule(options);
    });
});
